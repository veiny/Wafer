{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OpenGL Learn in 2024 main page my github page . glad demo #include <glad/glad.h> #include <GLFW/glfw3.h> #include <iostream> int main() { glfwInit(); GLFWwindow* window = glfwCreateWindow(1080, 760, \"LearnOpenGL\", NULL, NULL); if (window == NULL) { std::cout << \"Failed to create GLFW window\" << std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); /********************glad code***********************/ //1.\u521d\u59cb\u5316gladloadGLLoader if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout << \"Failed to initialize GLAD\" << std::endl; } //2.\u51c6\u5907\u6570\u636e,\u7ed1\u5b9a\u9876\u70b9\u6570\u636e float vertices[] = { -0.5f,-0.5f, 0.0f,0.5f, 0.5f,-0.5f }; const char* vertexShaderSource = \"#version 460 core\\n\" \"layout (location = 0) in vec3 position;\\n\" \"void main(){gl_Position = vec4(position.x, position.y, position.z, 1.0);}\\0\"; const char* fragmentShaderSource = \"#version 460 core\\n\" \"layout(location=0) out vec4 f_color;\\n\" \"uniform vec4 ourColor;\\n\" \"void main(){f_color=ourColor;}\\0\"; unsigned int VBO; //vertex buffer object glGenBuffers(1, &VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, 2 * 3 * sizeof(float), vertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); //layout(position=0) glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), 0); unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &vertexShaderSource, NULL); glCompileShader(vertexShader); unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL); glCompileShader(fragmentShader); unsigned int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); glUseProgram(shaderProgram); /********************glad code***********************/ // render loop while (!glfwWindowShouldClose(window)) { glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); float timevalue = (float)glfwGetTime(); float greenValue = (sin(timevalue) / 2.0f) + 0.5f; int vetexColorLocation = glGetUniformLocation(shaderProgram, \"ourColor\"); glUniform4f(vetexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); glDrawArrays(GL_TRIANGLES, 0, 3); glfwSwapBuffers(window); glfwPollEvents(); } glfwTerminate(); return 0; }","title":"OpenGL Learn in 2024"},{"location":"#opengl-learn-in-2024","text":"main page my github page .","title":"OpenGL Learn in 2024"},{"location":"#glad-demo","text":"#include <glad/glad.h> #include <GLFW/glfw3.h> #include <iostream> int main() { glfwInit(); GLFWwindow* window = glfwCreateWindow(1080, 760, \"LearnOpenGL\", NULL, NULL); if (window == NULL) { std::cout << \"Failed to create GLFW window\" << std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); /********************glad code***********************/ //1.\u521d\u59cb\u5316gladloadGLLoader if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout << \"Failed to initialize GLAD\" << std::endl; } //2.\u51c6\u5907\u6570\u636e,\u7ed1\u5b9a\u9876\u70b9\u6570\u636e float vertices[] = { -0.5f,-0.5f, 0.0f,0.5f, 0.5f,-0.5f }; const char* vertexShaderSource = \"#version 460 core\\n\" \"layout (location = 0) in vec3 position;\\n\" \"void main(){gl_Position = vec4(position.x, position.y, position.z, 1.0);}\\0\"; const char* fragmentShaderSource = \"#version 460 core\\n\" \"layout(location=0) out vec4 f_color;\\n\" \"uniform vec4 ourColor;\\n\" \"void main(){f_color=ourColor;}\\0\"; unsigned int VBO; //vertex buffer object glGenBuffers(1, &VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, 2 * 3 * sizeof(float), vertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); //layout(position=0) glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), 0); unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &vertexShaderSource, NULL); glCompileShader(vertexShader); unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL); glCompileShader(fragmentShader); unsigned int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); glUseProgram(shaderProgram); /********************glad code***********************/ // render loop while (!glfwWindowShouldClose(window)) { glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); float timevalue = (float)glfwGetTime(); float greenValue = (sin(timevalue) / 2.0f) + 0.5f; int vetexColorLocation = glGetUniformLocation(shaderProgram, \"ourColor\"); glUniform4f(vetexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); glDrawArrays(GL_TRIANGLES, 0, 3); glfwSwapBuffers(window); glfwPollEvents(); } glfwTerminate(); return 0; }","title":"glad demo"}]}